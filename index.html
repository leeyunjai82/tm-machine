<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Classification Training Tool</title>
    <script src="static/jszip.min.js"></script>
    <script src="static/tf.min-3.11.0.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
        }
        #file-container, #class-container {
            margin-bottom: 20px;
        }
        .class-item {
            margin-bottom: 10px;
        }
        img.thumbnail {
            width: 100px;
            height: 100px;
            object-fit: cover;
            margin: 5px;
        }
        #preview-container {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Image Classification Training Tool</h1>
    <div id="file-container">
        <button onclick="addNewClass()">Add New Class</button>
    </div>
    <div id="class-container">
        <!-- Classes will be added here dynamically -->
    </div>
    <div>
        <button onclick="trainModel()">Train Model</button>
        <button onclick="downloadModel()">Download Model</button>
    </div>
    <div id="preview-container">
        <h2>Model Preview</h2>
        <video id="webcam" autoplay width="224" height="224"></video>
        <button onclick="startPreview()">Start Preview</button>
        <h3>Predictions</h3>
        <ul id="predictions"></ul>
    </div>
    <script>
        let classes = [];
        let imagesByClass = {};
        let model;
        let webcamElement;

        async function addNewClass() {
            let className = prompt('Enter a name for the new class:');
            if (className) {
                classes.push(className);
                imagesByClass[className] = [];
                displayClass(className);
            }
        }

        function displayClass(className) {
            let classDiv = document.createElement('div');
            classDiv.className = 'class-item';
            classDiv.innerHTML = `<strong>${className}</strong> <input type="file" accept="image/*" onchange="handleImageUpload('${className}', this)" multiple />`;
            let imageContainer = document.createElement('div');
            imageContainer.id = `image-container-${className}`;
            classDiv.appendChild(imageContainer);
            document.getElementById('class-container').appendChild(classDiv);
        }

        function handleImageUpload(className, input) {
            let files = input.files;
            for (let i = 0; i < files.length; i++) {
                let reader = new FileReader();
                reader.onload = function(event) {
                    let img = document.createElement('img');
                    img.src = event.target.result;
                    img.className = 'thumbnail';
                    document.getElementById(`image-container-${className}`).appendChild(img);
                    imagesByClass[className].push(event.target.result);
                };
                reader.readAsDataURL(files[i]);
            }
        }

        async function trainModel() {
            const mobilenet = await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v2_1.0_224/model.json');
            const layer = mobilenet.getLayer('global_average_pooling2d');
            const truncatedModel = tf.model({inputs: mobilenet.inputs, outputs: layer.output});

            const newModel = tf.sequential();
            newModel.add(tf.layers.inputLayer({inputShape: [7, 7, 1280]}));
            newModel.add(tf.layers.flatten());
            newModel.add(tf.layers.dense({units: 100, activation: 'relu'}));
            newModel.add(tf.layers.dense({units: classes.length, activation: 'softmax'}));

            let xs = [];
            let ys = [];
            classes.forEach((className, classIndex) => {
                imagesByClass[className].forEach(imgData => {
                    const img = new Image();
                    img.src = imgData;
                    img.onload = () => {
                        let inputTensor = tf.browser.fromPixels(img).resizeNearestNeighbor([224, 224]).toFloat().div(tf.scalar(255.0)).expandDims();
                        let feature = truncatedModel.predict(inputTensor);
                        xs.push(feature);
                        ys.push(classIndex);
                    };
                });
            });

            const xTrain = tf.concat(xs);
            const yTrain = tf.tensor1d(ys, 'int32');

            newModel.compile({optimizer: 'adam', loss: 'sparseCategoricalCrossentropy', metrics: ['accuracy']});
            await newModel.fit(xTrain, yTrain, {epochs: 10});
            model = newModel;
        }

        function downloadModel() {
            if (model) {
                model.save('downloads://trained_model');
            } else {
                alert('Please train the model first!');
            }
        }

        async function startPreview() {
            if (!webcamElement) {
                webcamElement = document.getElementById('webcam');
                await tf.data.webcam(webcamElement);
            }
            setInterval(async () => {
                const img = tf.browser.fromPixels(webcamElement);
                const input = img.resizeNearestNeighbor([224, 224]).toFloat().div(tf.scalar(255.0)).expandDims();
                const predictions = model.predict(input);
                const predictedClassIndex = predictions.argMax(-1).dataSync()[0];
                const predictedClassName = classes[predictedClassIndex];
                document.getElementById('predictions').innerHTML = `<li>${predictedClassName}</li>`;
            }, 1000);
        }
    </script>
</body>
</html>
